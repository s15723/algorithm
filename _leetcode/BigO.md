# 时间复杂度分析

**什么是 `Big O`？**

    n 表示数据规模

    O(f(n)) 表示运行算法所需要执行的指令数，和 f(n) 成正比

    即 a * f(n)，随着 n 的增长，a将被忽略

**对数据规模有一个概念(可以根据这个快速确定可使用算法的时间复杂度)**

    如果想要在1s之内解决问题:

    O(n^2) 可以处理大约 10^4 级别的数据

    O(n) 可以处理大约 10^8 级别的数据

    O(nlogn) 可以处理大约 10^7 级别的数据

**空间复杂度**

    多开一个辅助的长度为 n 的数组: O(n)

    多开常数空间(声明一定数量的变量): O(1)

    递归调用是有空间代价的，递归的深度是多少(n)，整个递归过程的空间复杂度就是多少(O(n))

    // 如果递归中进行了多次递归调用呢？

**判断一个数是不是素数 O(sqrt(n))**
```ts
// n < 0; n = 0; n = 1; n > 1
function isPrime(n: number) {

}
```

**将数字整型转换成相应的字符串 O(nlogn)**
```ts
// n > 0; n = 0; n < 0
function intToString(n: number) {

}
```

**复杂度试验(我们到底写的是什么级别复杂的的算法？)**

    我们认为的写的算法的时间复杂度不一定是对的

    实验，观察趋势

    每次将数据规模提高两倍，看时间的变化

    O(logn) 性能很好，n 变大几乎看不到执行时间的变化(变化很小)

    所以 O(nlogn) 的性能很好，跟 O(n) 的差距并不大，完全可以接受

**递归算法的复杂度分析(真正关心的是计算调用的次数)**

- **递归中进行一次递归调用 O(T*depth)**
    如果递归函数中，只进行了一次递归调用，递归深度为 `depth`，在每个递归函数中，时间复杂度为 `T`，则总体的时间复杂度为 `O(T*depth)`。这个 `T` 如果为常数可以忽略。
```ts
// 如果 n 个 x 直接相乘，时间复杂度为 O(n)
// 现在要利用递归实现一个 O(logn) 的 pow
// 考虑 n > 0; n = 0; n < 0
function pow(x: number, n: number) {

}
```

- **递归中进行多次递归调用**
    关心计算调用的次数。其实第一种情况**递归调用的深度**相当于**递归调用的次数**。
    *以下面代码为例*
```ts
function f(n: number) {
    if (n < 0) {
        throw new Error('n must largerOrEqualThan 0')
    }
    if (n === 0) {
        return 1
    }
    return f(n-1) + f(n-1)
}
f(3)
```
如下，2^0 + 2^1 + ... + 2^n = 1 * (1-2^(n+1)) / 1-2 = 2^(n+1) - 1
即 `O(2^n)`
![O(2^n)](https://image-c.weimobwmc.com/wrz/77606c0c8b00448ab3a21862d3a6ba8c.png)

**均摊时间复杂度分析、避免复杂度的震荡(见[动态数组的实现](/packages/array/index.ts))**
